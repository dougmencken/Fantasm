




¥Lightsoft Cross Translation (LXTª) Set V2¥
Part No. LSA0500

Lightsoft
55 Sidney Street,
Grantham,
Lincs,
NG31 8AZ
 U.K.
mailto: support@lightsoft.co.uk
Visit The Programmers Dream at: http://www.lightsoft.co.uk





























This electronic version of the manual is designed to be viewed in at least 16 colours and preferably 256 or better.
For printing, set the page size to "A4"

Note - No warranty either expressed or implied is given with this software. It is sold on an as is basis, with no liability either offered or accepted by Lightsoft or its duly authorized agents.  If you cannot agree to, or accept this notice, then do not use this software.
Lightsoft Cross Translation Set (LXT)
 
Part Number: LSA0500

Published by:
Lightsoft, 55 Sidney street, Grantham,  Lincs.  NG31 8AZ.  U.K.
Copyright © Lightsoft 1997.

www: http://www.lightsoft.co.uk
email: support@lightsoft.co.uk

Printed in the United Kingdom using Apple Macintoshª computers.






























  LXTª is a technology for translating from one language to another using  macros 
  LXTª is  copyright ©Lightsoft 1997-9. LXT is a trademark of Lightsoft. 
  Intellectual Property Rights (IPR) are owned by Lightsoft U.K.

  Private Licensees may use LXTª in their software as long as acknowledgment is 
  given to Lightsoft. Corporate Licensees should contact Lightsoft for licensing details.
http://www.lightsoft.co.uk
 support@lightsoft.co.uk   
   
LXTª is not distributable by third parties
LXTª IS NOT PUBLIC DOMAIN
Contents

What is LXT?	6
What's needed?	6
How it works	7
Overview.	9
Detailed guidelines.	10
Conversion notes	13
Temporary registers	15
RUNNING OUT OF MACRO PARAMS	15
LIMITATIONS	16
Binary Coded Decimal maths	17
Index register addressing mode	17
LXT case sensitivity	17
DEFINITE NO-NO's	18
Optimizing an LXT project	19
More notes	20
Major Gotcha's	21
Acceptable instructions	22
Extensions to LXT for faster target code	25


Before making a start on converting your 68K project to a PowerPC one, please read these notes all the way through. 

Note: URL's and email addresses in this document are live - just click them to send an email or go to a URL.

What is LXT?

LXT is an assembler written in Fantasm 5 macro language (FML) that accepts 68K assembly language  and outputs PowerPC assembly language for assembly by the PowerPC assembler. 

LXT was originally written at Lightsoft (UK) in November/December 1997 as a portable low level language. Version 2 offers much improved PowerPC code generation and the ability to generate read/write check code at runtime to catch out of bounds memory read or writes offering bullet proof QA.

Code generated by LXT emulates exactly the 68K stack, so subroutine calls are handled automatically. This does mean more code than would be necessary is generated, but there is no "work" overhead for the programmer.

LXT translates 68K A5 global variables to PowerPC global variables based off of the BSS register. LXT requires no run time library, BCD maths instructions require the use of some tables included in an optional BCD library.

LXT does not output highly optimized target code. Instead the programmer can replace speed sensitive portions of 68K code directly with target assembly language. In many respects this is better than writing in a high level language for portability! Why? You KNOW what registers are in use, and at all times you have total control.

Because LXT is an interpreted assembler run on top of Fantasm, a fairly powerful machine is needed. Whereas Fantasm would take a second to assemble a file, it can take LXT sixty to translate the same number of lines.

What's really useful about LXT is that any part of it  can be changed in any way you  wish - it's all just macros, so you can change the subroutine calling method, the code generators, or just about anything else in any way you fancy. Granted that hitting another target processor is hard work, but it is at least possible.

Have fun!


What's needed?
Anvil hosting Fantasm 5.1.0/LinkPPC 4.90 or later. Fantasm 6 is recommended but is still in beta at time of writing.
 
Anvil will need at least 12 Megabytes of memory allocated to it. Use VM if necessary. 

Users should be familiar with Fantasm - see LSA040 for details.



Five files:
Universal_OS_calls.LXT - the interface to OS functions. A Globinc
LXT_68K_to_PPC.MAC - The actual cross assembler written in Fantasm Macro Language. A Globinc
LXT_Support_68k - Use if the project is 68K
LXT_Support_PPC - Use for your PPC project
LXT_Speed_extensions - optional extensions to LXT to produce faster PowerPC code.

One (optional) library:
LXT_RT.lib  This is needed if you wish to translate the 68K BCD maths instructions.

A PowerMac.

LSA0500 - this document.

Patience.


How it works

You don't need to know the information in this section; it's quite skippable.

LXT has to translate your source code and data to a form suitable for assembly by the target assembler. For 68K this simply entails removing any LXT speed extension code (qmove for example, see later text) and replacing it with standard 68K code. For PPC the code and data declarations must be translated to a form suitable for assembly by the PPC assembler. 

When translating to PPC, LXT has to translate the code, the data and data space definitions. The code translation is handled by the macros defined in LXT_68k_to_PPC and some additional Fantasm extensions. The data translation is carried out by some new Fantasm extensions (size_68k for example) as is the data space and global variables translations.

Of primary concern was how to handle the OS interface. This is achieved by providing a set of macros - one for each OS function. The macro is split into 68K and PowerPC sections as per this simple example
OSSetWTitle:	macro	*window,title ptr
	macs_last	*avoid clashes with real instructions
	if 68k
	move.l	\1,-(sp)
	move.l	\2,-(sp)
	dc.w	_SetWTitle
	
	else
	map_in_2	\1,\2
	Xcall	SetWTitle
	endif
	macs_first	  *back to translate mode
	endm
There are some directives here you may not be familiar with. macs_last and macs_first tell Fantasm whether to search the macros last or first, given any instruction. If we take a line like:
	addi	#1,d0
addi is a perfectly valid 68K instruction. It is also a perfectly valid PPC instruction! 

Now, assume we are translating from 68K to PPC. If the instruction table was searched first (as per normal Fantasm operation), the assembler would find addi then call the evaluator to decode #1. Unfortunately,  #1 is gobbledygook as far as the PPC assembler is concerned and a syntax error would result. The macs_first directive allows us to tell Fantasm to search the macros before the instruction table. In the macros we can define a macro to correctly handle the addi 68K to PPC translation. 

When assembling an OS call, we need the assembler back in normal mode so we can generate target code, hence the macs_last directive at the start of the macro and the macs_first at the end. 

The macro map_in_2 maps two macro parameters to PPC registers for parameter passing - in this case it would map param1 to r3 and param2 to r4. These macros extend up to 9 parameters. There is also a macro to map_out from r3 to the destination parameter, which always appears at the end of the parameter list.

Parameters to the OS calls are always passed in registers irrespective of whether  your target is 68K or PPC.

The actual translation of a 68K instruction to PPC is handled by the macros in LXT_68K_to_PPC. Only a sub-set of 68K instructions and addressing modes are handled (see the end of this document for a current list). Each 68K instruction we handle as a macro in here - add, sub, move etc.These macros call the  core macro  get_ops (defined in PPC_Support) to decode the operands' addressing modes. This macro is called by nearly all the other translators. It returns offsets and registers for both source, destination and in some cases index registers. It calls get_mode for each operand. get_mode returns a numeric code (in mode_1, mode_2) for each source and destination addressing mode and sets up the register strings [r$], [s$] as appropriate. get_mode relies heavily on the new directive in Fantasm 5.1 fndc which searches a string for the first occurrence of a character.

Overview.

For LXT to auto translate your 68K assembly language project to a PowerPC executable, you have to modify your 68K source to make it compatible with LXT. 

This entails the following:

1. Call the OS through the macros found in Universal_OS_Calls.LXT only. You may need to add new macros for calls not covered by LXT. 

It's worth calling the OS through these interface macros, even for Òhand rolling Ó assembly language projects not using LXT, as an aid future maintainability and portability UNLESS you can't afford the speed reduction introduced by  setting up and tearing down a stack frame on every OS call (two PPC instructions, using a modified Xcall macro). All parameters to the OS function are passed in registers which will entail source level modifications. A new .def file called Universal_OS_calls.def is provided with Fantasm 5.1 for this purpose.

2. All accesses to "low memory" or system variables MUST be done through the macros found in Universal_OS_Calls.LXT

3. Modifying any callbacks etc. to be passed in universal procedure pointers
(best set up at init time - see notes on subsequent pages)

4. Possibly simplifying your 68K code. LXT does not support the more complex 68K addressing modes for example.

5. Checking that all 68K subroutines that use local variables do not jump out of themselves into another subroutine.

6. Check that all 68K data directives start on the same line as the data label.
For example:
fred:
	dc.b	"Hello Fred"
is perfectly legal for the 68K assembler but fred will become a code label under
the PPC assembler. Change it to:
fred:	dc.b	"Hello Fred"
alternatively:
fred:	data
	dc.b	"Hello Fred"

7. Check that all data definitions are placed at the end of the source file.

8. Checking the code is case sensitive - LXT, unlike the 68K assembler is (very) case sensitive.
(See LXT case sensitivity below).

9. You may want to split your code up into smaller section to speed up "turn around" time.

Detailed guidelines.

Step 0:
Completely back up your 68K project twice. Now back it up again, just in case.

Step 1:
Go through all your 68K source files and change all OS calls to calls to the macros as defined in the file Universal_OS_Calls.LXT.  Note that when translating to PPC, these calls will be case sensitive, so ensure you get the case of the macro calls correct.

All the OS interface macros take parameters in registers only.

For example, if you called GetNewCWindow with the following code:
68K
	clr.l	-(sp)
	move.w	#128,-(sp)	*resource number
	pea	my_window_record(a5)	*pointer to where record will go
	clr.l	-(sp)		*Behind which window? (Zero=in front)
	dc.w	_getnewcwindow
	move.l	(sp)+,my_window(a5)

You must change it to:
LXT
	qmove.l	#128,d0
	lea	my_wind_record(a5),a0
	clr.l	d2		*BEHIND?
	OSGetNewCWindow	d0,a0,d2,d0

Another example:
68K
	clr.l	-(sp)
	dc.w	_TickCount
	move.l	(sp)+,d0
becomes:
LXT
	OSTickCount	d0

In our experience, nearly all post conversion bugs will relate to the recoding of the OS calls. See "Conversion notes" below for more info.

If a macro for the OS function you wish to call is not present, you will need to add the relevant macro, taking into account both 68K and PowerPC calling conventions.


Step 2:
VERY IMPORTANT. Search all your source files for any 68K dc.w directives used to call OS functions you may have missed! This could save you a lot of time later.


Step 3: Either make the file Universal_OS_calls.LXT a globinc, or include it into
all your 68k source files that needs it - i.e. all those with OS calls in. The files
LXT_Speed_extensions and LXT_Support_68k also need to be made globincs.



----------
IMPORTANT: LXT_SPEED_EXTENSIONS MUST BE GLOBINC'D BEFORE ANY OTHER LXT FILES AND ALL LXT FILES REQUIRED MUST BE PLACED IN YOUR GLOBINCS BEFORE ANY OTHER GLOBINCS YOUR PROJECT MAY REQUIRE!
----------

Step 4: Build, test and debug your 68K project. It's easier to do this as you change
each source file to use the OS calling macros during the above stages.

Step 5: When you have built and verified the integrity of your new 68K project, create a new PowerPC project the same as the 68K one. Make LXT_68K_to_PPC.mac and LXT_Support_PPC globinc's and Build.

If your project builds and runs first time, you are leading a charmed life!

Step 5 details:
Your program should start with the following:
	entry
	if	68k
	bsr.l	a5_init
	else
	LXT_Init	*init LXT
	endif
	bsr.l	init_mac	*At end of this file - replaces lib routine
	**Carry on with your code

Init_mac typically looks like this:
init_mac:
	lea	qdglob(pc),a0	quick draw work space
	lea	202(a0),a0	add 202 to a0 quickly
	OSInitGraf	a0
	OSInitFonts
	OSInitWindows
	OSInitMenus
	move.l	#0,d0		*resume proc
	OSInitDialogs	d0
	OSTEInit
	OSInitCursor
	lea	qdglob(pc),a0	return address of qd vars.
	rts_	"Init_mac"
qdglob:	ds.b	210
	align

A very useful tip is to go to the PPC linker preferences and switch on "Export all global code labels". This will make debugging easier.
The LXT files contain a macro "illegal" which can be used to drop into your low level debugger as needed.

IMPORTANT: THE PPC PROJECT MUST NOT CALL ANY STANDARD STATIC LIBRARIES. PPC STATIC LIBRARIES ASSUME DIFFERENT CALLING CONVENTIONS FROM LXT. ANY STATIC LIBRARY FUNCTIONS NEEDED MUST EITHER BE PLACED IN THE SOURCE AS SOURCE CODE (PROVIDED ON YOUR FANTASM 5 CD) OR YOU MUST REBUILD THE STATIC LIBRARY USING LXT.




Globincs Summary
68K project globincs:
lxt_speed_extensions
lxt_Support_68k
Universal_OS_Calls.LXT

PPC project Globincs
lxt_speed_extensions
lxt_support_PPC
lxt_68k_to_ppc
Universal_os_calls.LXT





Conversion notes

1. Parameters are passed to OS calls in registers. 
Register mapping is as follows:
d0=r3
d1=r4
d2=r5
d3=r13
d4=r14
d5=r15
d6=r16
d7=r17
a0=r20
a1=r21
a2=r22
a3=r23
a4=r24
a5=r25
a6=r26
a7=sp 

Because parameters are passed to OS calls in registers, ensure you have no register overlap when generating PPC code. For example, if we call a function that takes three parameters:
 OSfunction d2,d1,d0
because d0 is mapped to r3 and in PPC r3 is the first parameter, LXT will not generate code to move the parameters around. Instead you will get a warning about parameter overlap and will need to reorganize the call so it reads
OSfunction d0,d1,d2

ONLY THE FIRST 3 PARAMETERS ARE CHECKED FOR OVERLAP.

2. Global variables
LXT maps the globoff directive to the RS directives. Thus in 68K, your globals are defined as negative offsets from a5, whilst in PPC they are mapped as positive offsets from the BSS. This may have connotations if you have assumed some specific ordering of your globals; for example you read a file into them.

3. Callbacks
You may need to use callbacks and/or pass pointers to code under some conditions. Examples are scrollbar controllers, apple event handlers, custom file selectors, external code linkage etc.

In 68K one just passes the address of the callback function. PowerPC requires
you pass a universal procedure pointer. The best way in LXT is to always use
a UPP or alternatively assemble the correct code depending on whether the PPC or
68K assembler is running. 
Creating a UPP:
**dialog filter	
	lwz	r3,MyFilterTV(rtoc)		; TV here in data
	lwz	r4,[t]my_filter_proc(rtoc)	; Actual pointer to code
	stw	r4,(r3)				; into transition vector
	stw	rtoc,4(r3)					; followed by our toc
	lwz		r3,MyFilterTV(rtoc)
	li		r4,$00000FD0		; params- return byte, 3 longs on stack in
 	li		r5,kPowerPCISA
	Xcall	NewRoutineDescriptor
	move.l	d0,modaldialog_upp(a5)						;save UPP
Where MyFilterTV is defined as:
	align
MyFilterTV:	ds.l	2

Example usage:

	if	PPC
kPowerPCISA						EQU		1
	lwz	r3,MyFilterTV(rtoc)		; Create transition vector in data section
	lwz	r4,[t]my_filter_proc(rtoc)	; Actual pointer to code
	stw	r4,(r3)				; into transition vector
	stw	rtoc,4(r3)				; followed by our toc

	lwz	r3,MyFilterTV(rtoc)
	li	r4,$00000FE0		; parameter passing info (IM PPCSystemSW)
 	li	r5,kPowerPCISA
	Xcall	NewRoutineDescriptor
	mr	r16,r3				;save UPP
	endif
**********
	if	PPC
	mr	r20,r16		;UPP into a0
	else
	lea	my_filter_proc(pc),a0
	endif
**Save a5 for our filter proc!
	lea	my_a5_store(pc),a1
	move.l	a5,(a1)
	move.l	a6,4(a1)	*Save our regs we need in filter proc
	lea	item(pc),a1
	OSModalDialog	a0,a1

In your callback function you will need two conditionally assembled code sections - one to handle the 68K parameter passing and one to handle the PPC parameter passing. Similarly at the end of your callback function you will again need two conditionally assembled code sections to return correctly.

WHY? LXT emulates the 68K stack precisely, but when a callback is called the OS knows nothing of the emulated stack and passes parameters in registers are per normal PPC conventions.

Example:
This is the entry code for the modal dialog filter function.
	if	PPC
my_filter_proc:	toc_routine
	else
my_filter_proc:
	endif

	if	PPC
	mflr	r6
	stwu	r6,-4(sp)	*push rts onto stack

	mr	r7,r5		*item hit - notice reverse parameters!
	mr	r21,r4	*Event record to a1
	mr	r16,r3	*pointer to dialog window to d6
	mr	r4,r7		*pointer to item hit in d1
	else
	move.l	(sp)+,a0	rts
	move.l	(sp)+,d1	item hit
	move.l	(sp)+,a1	eventrec
	move.l	(sp)+,d6	dialog window
	addq.l	#2,sp	* - why? PASCAL PARAMETER - byte return value!
	endif
	move.l	a5,-(sp)	*Save the current a5 (r25) and pop off before we exit
	push	a0
	lea	my_a5_store(pc),a0
	move.l	(a0),a5		*Get our a5! <-NOTE THIS!
	move.l	4(a0),a6	*and our a6
	pop	a0
**Do filter processing

**Returning from filter function
	move.l	(sp)+,a5
	if	PPC
	li	r3,-1	*return what you need to
	rts
	else
	move.b	#-1,-(sp)
	jmp	(a0)
	endif

Note that our emulated a5 (r25) is NOT preserved for us when we run in the callback, when running under PPC. Hence in the code that calls ModalDialog we must store a5 and a6 if needed in an easily accesible place - the LXT code to do this looks like this:
**Save a5 for our filter proc!
	lea	my_a5_store(pc),a1
	qmove.l	a5,(a1)
	qmove.l	a6,4(a1)	*Save our regs we need in filter proc

Alternatively, you can use the RefCon parameter if available.

Temporary registers
LXT uses some temporary registers you should be aware of:
zero:	reg	r27	*For clears. We can't load this up permanently because in 
			*callbacks it's sometimes trashed.
temp_reg1:	reg	r11
temp_reg2:	reg	r12
temp_reg3:	reg	r9	*due to the design, this never interferes with parameters.

*r18,19,28 - stack - used for qpush and qpop
stack_reg1:	reg	r18
stack_reg2:	reg	r19
stack_reg3:	reg	r28

RUNNING OUT OF MACRO PARAMS
Fantasm provides 9 macro parameters. For some OS calls this is not enough. CustomGetFile for example uses 11 parameters. If one needs to use all 11 parameters then the macro can be pasted in-line in the code and the extra parameters moved onto the stack. 

Note that parameter1 starts at SP+24 after the stack has been decremented. You may or may not want to copy all the parameters into the stack parameter area. Inside Mac states that only parameters that can't be accommodated in registers should be stored in the parameter area. You will note that in OSCustGetFile and PutFile we have nonetheless copied all parameters to the stack out of paranoia.

LIMITATIONS
LXT does not emulate the 68K carry flag with the exception of the BCD instructions. Many 68K branch instructions are not catered for. In these cases, LXT will generate an error.
You will need to simplify your code.

READ/WRITE BOUNDS CHECK

In file LXT_68K_to_PPC.MAC set check_writes and/or check_reads to enable the read/write address validity checking code. See LXT_68K_to_PPC.MAC for details.

Binary Coded Decimal maths
abcd and bcd are catered for in a limited way. They use tables contained in the library LXT_RT_Init. If you translate these instructions, be sure to add this static library to your PPC project.

Index register addressing mode
LXT supports the index register for the following destination cases only:
move.size	x,x(an,dn.size)
clr.size	x(an,dn.size)
tst.size	x(an,dn.size)
cmp(i).size	x(an,dn.size)
Index registers in source addressing modes will lead to an error.

NOTE THAT SCALING FACTORS ARE NOT ALLOWED - x(an,dn.size*scale)


LXT case sensitivity
This is a list of LXT register names and sizes cased exactly as needed:
d0
d1
d2
d3
d4
d5
d6
d7
a0
a1
a2
a3
a4
a5
a6
a7
sp
pc
.b
.w
.l
.s

Thus the code:
	move.L	d0,D3
will not be accepted.
First the .L will not be recognized as a valid size, secondly D3 is an undefined identifier as far as LXT is concerned.

DEFINITE NO-NO's

1. lea	fred+x(pc),a0

LXT cannot handle this kind of addressing when used in conjunction with the PC.
Change to:
	lea	fred(pc),a0
	addq.l	#x,a0
If the value of x is greater than +-8 then use an lea instruction.
	lea	fred(pc),a0
	lea	x(a0),a0


2. Passing a routine address to another routine which will call the routine passed to it. LXT can't handle this situation.

Either use a branch table - the size of each entry (in bytes) can be calculated from the LXT definitions (defined when translating 68K to PPC):
sizeof_bsr
sizeof_rts
sizeof_bra
or use a series of conditionals or toc_routines to branch to the right routine.

NOTE: In the current implementation a special form of rts (rts44) is available which when used with a standard bsr will generate code that is precisely 64 bytes long. You will need special case code in this case:

	if	PPC
	macs_last
	lwz	r21,[t]ppc_my_table(rtoc)
	slwi	r3,r3,6		*each entry is 64 bytes PPC code
	add	`temp_reg2,r3,r21
	mtctr	`temp_reg2		*where we go to
	bl	here2
here2:				*address of here2 in link register
	mflr	`temp_reg1						- 4 bytes
	addi	`temp_reg1,`temp_reg1,16	*add 4 instructions for this code
	stwu	`temp_reg1,-4(r1)			*put return address on stack
	bctr		*16 bytes from "here" to return instruction
	macs_first
	else
	lea	ppc_my_table(pc),a1
	lsl.l	#3,d0		*Each entry is 8 bytes 68K code
	add.l	d0,a1
	jsr	(a1)	*To correct branch in branch table
	endif


3. You MUST NOT link to any libraries other than LXT ones (there's only one - the BCD maths support). The reason for this is that LXT code is PowerPC (or 68K) code that emulates the 68K run-time architecture. Any library functions in use before conversion to LXT must either be rewritten as an LXT library or you can simply place the source for the requiered function in your code.




Optimizing an LXT project

PowerPC target code generated by LXT is slowed by the necessary checking of flags when data is moved.
For example:
	move.l	d0,d1
could generate
	cmpwi	r3,0
	mr	r4,r3
when generating PPC code (it does it in one instruction actually, but this is for example purposes only).
This is extremely convenient from the point of view of LXT emulating the run time architecture, but severely slows the code down. Most times you do not need the flags setting!
The file LXT_Speed_extensions contain additional LXT instructions that do not set any flags. For example the instruction qmove compiles as:
	qmove.l	d0,d1
generates
	mr	r4,r3
If the target was 68K it would generate
	move.l	d0,d1

There are other "q" additions to the standard 68K instructions - see LXT_Speed_extensions for all possibilities.

An extension of the "q" prefix is the "qc" prefix, which again sets no flags. It is used to quickly move an unsigned 8 or 16 bit quantity into a register and has the effect of first clearing the register and then performing the move:
	qmove.b	fred(a5),d0
**68K code generated:
	clr.l	d0
	move.b	fred(a5),d0
**PPC code generated
	lbz	r3,fred(r25)

compared to:
	 move.b	fred(a5),d0
**68K code generated:
	move.b	fred(a5),d0
**PPC code generated
	lbz	`temp_reg,fred(r25)
	mr_8	r3,`temp_reg1	*Macro to move a given bit sized quantity and test the result

Thus the qc moves will speed the PPC code up.

qdbra is the same as dbra but decrements the whole 32 BITS of the loop control count register, whereas dbra decrements just the lower 16 bits of the count register. qdbra is much faster than dbra but you must ensure the count register has a valid 32 BIT count value in it. In both cases, the loop is terminated when the count register contains -1. Other decrement and branch forms are not emulated; dbne for example.

For an example of creating and optimizing  a fat app with LXT, please see the project for LS New Year 1998 Demo which was written in LXT.

More notes

These notes are taken from our experience with LXT and were written after the previous pages were completed. 

It's very important to realize that what LXT will give you on a first translation is very poor PowerPC code. It'll be a very faithful translation of the 68K code and environment, which is precisely why it's poor PowerPC. After successfully getting your project running with PowerPC code you then have the relatively easy job of basic optimizing as follows:

1. Go through all the source and change all moves that are not directly followed by a conditional operation - i.e. a branch or set, to qmoves. LXT will warn you if you precede a conditional branch with a qmove instruction, so you needn't worry about this.

2. Change all unsigned 68k loads to the qcmove form:
	clr.l	d0
	move.b	 fred(a5),d0
becomes
	qcmove.b	fred(a5),d0

3. Change all clr.x Dn's to qmove #0,Dn
clr has to set the flags so a qmove saves an instruction.

4. Change as many dbra's to qdbra's. To be able to do this, you MUST ensure the count register contains a 32 bit count value rather than a 16 bit one - for example:
	move.w	#320,d0
loop:
	some code
	dbra	d0,loop
becomes
	qmove.l	#320,d0
loop:
	some code
	qdbra	d0,loop	*much faster.

5. If an operation could be performed as a 32 bit operation rather than 8 or 16 bits, change it to 32 bit code, for example:
	move.b		fred(a5),d0
	cmp.b	#32,d0
becomes
	qcmove.b	fred(a5),d0	*quick clear and move with no result tests
	cmp.l	#32,d0
Note: If you need both 68K and PowerPC executables, this modification will be to the detriment of the 68K run time speed. See (9).

6. LXT is particularly poor at bit tests and sets- avoid if possible! For more info see the translators for this group.

7. 32 bit multiplies and divides translate to much faster code than the 16 bit divides and multiplies.
Use mul(su).l and div(su).l wherever possible unless you really need the emulation of the 16 bit 68k div/remainder operation (which is emulated exactly) or the 16*16 bit multiply, or you need compatibility with the basic 68000 processor in your 68K code.

8. bsr and rts are emulated exactly. This means these instructions generate a lot of code and naturally push and pop to the stack. If you have a subroutine which is called very frequently it is worth dropping into PPC and writing your own call and return code. NOTE that if the subroutine is not a leaf routine then you MUST save the LR.
LXT provides qbsr and qrts which translate in PPC to bl and blr. Obviously, all bsr's to the routine will need changing to qbsr.

9. For tight loops, drop into PPC, use the count register and "go schedule" using the SWG.

9a. If the LXT code isn't running fast enough then drop into the target code with an IF PPC/ELSE/ENDIF conditional.

10. Watch out for possible scheduling in the 68K code - for example you can throw address arithmetic in-between a compare and it's associated conditional branch.

11. Where you need to save some registers on the stack temporarily, use qpushx and qpopx (where x is a number between 1 and 3). These save up to 3 registers in other PowerPC registers and don't use the stack.  The popping order must be the reverse of the push order. We do not recommend the use of qpush and pop if there is a subroutine call in-between, just in case you forget you have pushed into one of the registers. 

Major Gotcha's
All of the following are the result of many hours try to figure out exactly what the heck is going on! 

These are priceless.

1. LXT_68K_to_PPC does not (officially) recognize a7 as being the stack pointer! Use sp only.

2. You can't use commas as immediate data in double quotes anywhere - use 0x2c instead.

3.  Similarly, you cant use the "\" character ANYWHERE - this is picked up by the macro processor as a possible macro parameter, even within strings. Again use the hex equiv. 0x5c

4. Using the character combination "\@" anywhere as data will really ruin your day. General symptoms are your machine just freezes and if you don't know about it, it'll take a while to work out what's going on. Again use the hex equiv. 0x5c40

5. One single, errant proc_68k directive in your source will lead to a macro nesting error when translating to PPC. For this specific reason, Fantasm 5.1 prints a string to the log window for both proc_ppc and proc_68k directives. The LXT files set up the PPC assembler and expect it to stay that way. This doesn't mean you can't use proc_68k - just remember to proc_ppc when you are done generating 68K code (for whatever reason). In this case, the 68K code must be surrounded thus:

	macs_last
	proc_68k
	some 68K code
	proc_ppc
	macs_first

6. When dropping into target code, the code must be surrounded by macs_last and macs_first directives.



Acceptable instructions
This is a list of instructions that LXT 68K to PPC will currently translate. Not all possible addressing modes for any given instruction are implemented. Notes about instructions are given where applicable.
 
move
movea
moveq

movem   Note - only a list separated by "/" characters is acceptable. You can't use the "-" character when defining a register list for this instruction.

The ordering in this list is as per the translator definitions in LXT_68K_to_PPC.MAC

clr

swap

ext

exg

st

sf

bsr

bmi

bcc (restricted to use within BCD math operations)

bcs (restricted to use within BCD math operations)

bpl

bra

beq

dbra	(this is the only form translated) 

jmp

jsr

lea

pea

cmpi

cmp

cmpa

cmpm

tst

rts

sbcd	(requires a static library LXT_PPC_RT_LIB to be linked with your code)

abcd

link

unlk

sub

subi

add

addi

addq

subq

neg

divu	(32 bit long form is MUCH quicker than 16 bit form - remainder calcs require a multiply)

divs	(see note for divu)

muls	(32 bit long form is quicker by 1 cycle than 16 bit form)

mulu	(See note for muls)

extb

lsr

lsl

andi

eori

or

and

eor

not

btst

bset

bclr

bchg

Extensions to LXT for faster target code

qmove  Same as move but no flags are set - i.e. a possible cmp instruction is not needed.

qmovea  An alias for qmove which handles address registers as the destination operand.

qcmove  Used only when destination is a data register and has the effect of clearing the register before loading the variable sized data. Much faster (and generates far less code in some circumstances) than the respective move instruction under PPC.

qdbra  Used when the count register is guaranteed to contain a 32 bit rather than a 16 bit count value. Somewhat faster than dbra.

qpush(1..3)/qpop(1..3)  The PPC code generator sets aside three registers to hold three temporary values that would normally be pushed onto the stack. The ordering of pushing and popping is monitored by LXT and errors generated if you pop in the wrong order or try to pop a non existent datum. E.g.
qpush1	d0
...
qpop2	d0
would generate an error.
qpush1	d0
..
qpop1	d0
would not generate an error.








© Lightsoft 1999. 
Release #1 - LXT version 2.00
Please send comments/questions to support@lightsoft.co.uk
Thank you.